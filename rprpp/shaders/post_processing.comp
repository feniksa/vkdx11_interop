#version 450
// these defs are provided by shaderc lib
// #define WORKGROUP_SIZE 32
// #define OUTPUT_FORMAT rgba8/rgba32f provided by shaderc lib
// #define AOVS_ARE_SAMPLED_IMAGES
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct ToneMap {
    vec3 whitepoint;
    float vignetting;
    float crushBlacks;
    float burnHighlights;
    float saturation;
    float cm2Factor;
    float filmIso;
    float cameraShutter;
    float fNumber;
    float focalLength;
    float aperture;
    // paddings, needed to make a correct memory allignment
    float _padding0; // int enabled; TODO: probably we won't need this field
    float _padding1;
    float _padding2;
};

struct Bloom
{
    float radius;
    float brightnessScale;
    float threshold;
    int enabled;
};

layout (set = 0, binding = 0, OUTPUT_FORMAT) uniform image2D outputBuffer;
#if AOVS_ARE_SAMPLED_IMAGES
layout (set = 0, binding = 1) uniform sampler2D aovColor;
layout (set = 0, binding = 2) uniform sampler2D aovOpacity;
layout (set = 0, binding = 3) uniform sampler2D aovShadowCatcher;
layout (set = 0, binding = 4) uniform sampler2D aovReflectionCatcher;
layout (set = 0, binding = 5) uniform sampler2D aovMattePass;
layout (set = 0, binding = 6) uniform sampler2D aovBackground;
#define LOAD_AOV(texSampler, xy) texture(texSampler, vec2((float(xy.x) + 0.5f) / imageSize(outputBuffer).x, (float(xy.y) + 0.5f) / imageSize(outputBuffer).y))
#else
layout (set = 0, binding = 1, rgba32f) uniform readonly image2D aovColor;
layout (set = 0, binding = 2, rgba32f) uniform readonly image2D aovOpacity;
layout (set = 0, binding = 3, rgba32f) uniform readonly image2D aovShadowCatcher;
layout (set = 0, binding = 4, rgba32f) uniform readonly image2D aovReflectionCatcher;
layout (set = 0, binding = 5, rgba32f) uniform readonly image2D aovMattePass;
layout (set = 0, binding = 6, rgba32f) uniform readonly image2D aovBackground;
#define LOAD_AOV(img, xy) imageLoad(img, xy)
#endif
layout (set = 0, binding = 7) uniform UBO 
{
    ToneMap tonemap;
    Bloom bloom;
    float shadowIntensity;
    float invGamma;
} ubo;


vec4 clamp4(vec4 val, float minVal, float maxVal)
{
    return vec4(
        clamp(val.x, minVal, maxVal),
        clamp(val.y, minVal, maxVal),
        clamp(val.z, minVal, maxVal),
        clamp(val.w, minVal, maxVal)
    );
}

vec4 compose(ivec2 xy)
{
    vec4 color = LOAD_AOV(aovColor, xy);
    float opacity = LOAD_AOV(aovOpacity, xy).x;
    float shadow = min(ubo.shadowIntensity * LOAD_AOV(aovShadowCatcher, xy).x, 1.0f);
    float reflection = LOAD_AOV(aovReflectionCatcher, xy).x;
    vec4 mattePass = LOAD_AOV(aovMattePass, xy);
    vec4 background = LOAD_AOV(aovBackground, xy);

    vec4 colorSubMatte = clamp4(color - mattePass, 0.0f, 1.0f);
    mattePass = background * (1.0f - min(opacity + reflection, 1.0f)) + mattePass;
    color.xyz = mattePass.xyz * (1.0f - shadow) + colorSubMatte.xyz;
    color.w = opacity + shadow;

    return clamp4(color, 0.0f, 1.0f);
}

float CIE_luminance_RGB(vec3 rgb) { return rgb.x * 0.176204f + rgb.y * 0.812985f + rgb.z * 0.0108109f; } // linear CIE RGB
float weighted_luminance_RGB(vec3 rgb, vec3 w) { return rgb.x * w.x + rgb.y * w.y + rgb.z * w.z; }
float lerp(float a, float b, float t) { return a + t * (b - a); }

vec4 tonemap(vec4 color, ivec2 pos, ivec2 resolution)
{
    float invAspectRatio = 1.0f / (float(resolution.x) / float(resolution.y));
    vec2 invResolution = 1.0f / vec2(resolution);
    float vignetting_div2 = ubo.tonemap.vignetting * 0.5f;

    vec3 cm2DivWhitepoint = vec3(
        ubo.tonemap.whitepoint.r > 0.0f ? 1.0f / ubo.tonemap.whitepoint.r : 1.0f, 
        ubo.tonemap.whitepoint.g > 0.0f ? 1.0f / ubo.tonemap.whitepoint.g : 1.0f, 
        ubo.tonemap.whitepoint.b > 0.0f ? 1.0f / ubo.tonemap.whitepoint.b : 1.0f
    );

    if (ubo.tonemap.filmIso > 0.0f) {
        float mod = 18.0f / (106.0f * 15.4f);
        mod *= ubo.tonemap.cm2Factor * ubo.tonemap.filmIso;
        mod /= ubo.tonemap.cameraShutter * ubo.tonemap.fNumber * ubo.tonemap.fNumber;
        cm2DivWhitepoint *= mod / CIE_luminance_RGB(cm2DivWhitepoint);
    } else {
        cm2DivWhitepoint *= ubo.tonemap.cm2Factor / CIE_luminance_RGB(cm2DivWhitepoint);
    }

    if (vignetting_div2 != 0.0f) {
        float f0 =  pos.x * invResolution.x - 0.5f;
        float f1 = (pos.y * invResolution.y - 0.5f) * invAspectRatio;
        float f2 = ubo.tonemap.focalLength * ubo.tonemap.focalLength;
        color.xyz *= pow(
            f2 / (ubo.tonemap.aperture * ubo.tonemap.aperture * (f0 * f0 + f1 * f1) + f2), 
            vignetting_div2
        );
    }

    color.xyz *= cm2DivWhitepoint;

    float burnHighlights = max(ubo.tonemap.burnHighlights, 0.0001f); //1=no scaling,0=reinhard simple tonemapping //!! magic to avoid problems with inverse
    vec3 luminanceWeight = vec3(0.176204f, 0.812985f, 0.0108109f);
    float rgbl = weighted_luminance_RGB(color.xyz, luminanceWeight);
    color.x *= (rgbl * burnHighlights + 1.0f) / (rgbl + 1.0f);
    color.y *= (rgbl * burnHighlights + 1.0f) / (rgbl + 1.0f);
    color.z *= (rgbl * burnHighlights + 1.0f) / (rgbl + 1.0f);

    float wl = weighted_luminance_RGB(color.xyz, luminanceWeight);
    color.x = lerp(wl, color.x, ubo.tonemap.saturation);
    color.y = lerp(wl, color.y, ubo.tonemap.saturation);
    color.z = lerp(wl, color.z, ubo.tonemap.saturation);

    float crushBlacks = ubo.tonemap.crushBlacks + ubo.tonemap.crushBlacks + 1.0f; //1=no scaling,0=dark stuff gets even darker
    if (crushBlacks > 1.0f) {
        float intens = weighted_luminance_RGB(color.xyz, luminanceWeight);
        if (intens < 1.0f) {
            float sqrt_intens = sqrt(intens);
            color.x = lerp(pow(color.x, crushBlacks), color.x, sqrt_intens);
            color.y = lerp(pow(color.y, crushBlacks), color.y, sqrt_intens);
            color.z = lerp(pow(color.z, crushBlacks), color.z, sqrt_intens);
        }
    }
    
    return color;
}

void main() {
    ivec2 resolution = imageSize(outputBuffer);
    if(gl_GlobalInvocationID.x >= resolution.x || gl_GlobalInvocationID.y >= resolution.y)
        return;

    ivec2 xy = ivec2(gl_GlobalInvocationID.xy);
    vec4 color = compose(xy);
    color = tonemap(color, xy, resolution);
    color = vec4(
        pow(color.x, ubo.invGamma), 
        pow(color.y, ubo.invGamma),
        pow(color.z, ubo.invGamma), 
        color.w
    );

    imageStore(outputBuffer, xy, color);
}
